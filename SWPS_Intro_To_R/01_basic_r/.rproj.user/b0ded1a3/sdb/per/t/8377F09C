{
    "collab_server" : "",
    "contents" : "#tutaj zapiszemy nasz kod\nobiekt1 = 10\n\nobiekt2 = log1p(obiekt1)^2\n\nobiekt3 = round(obiekt2, 0)\n\nobiekt4 = obiekt3 > obiekt2\n\nobiekt5 = FALSE*obiekt4\n\n#pomoc dot. funkcji\n?log1p\n\nhelp(\"round\")\n\n#obiekty mogą być tekstowe\n\nzdanie1 = \"Ala ma\"\nzdanie2 = \"kota\"\n\nzdanie3 = paste(zdanie1, zdanie2, sep=\" \")\n\nzdanie3_male = tolower(zdanie3)\nzdanie3_duze = toupper(zdanie3)\n\n#konwersja typów\n\nobiekt6 = \"12\"\nobiekt7 = 12\n\nprint(obiekt6+1)\nprint(obiekt7+1)\n\nobiekt6_liczbowy = as.integer(obiekt6)\n\nprint(obiekt6_liczbowy+1)\n\nzdanie4 = paste(zdanie3,\"oraz\",as.character(3),\"psy\", sep=\" \")\n\n#zadanie 1\n\nx1= 1000\nx2 = \"50\"\nx3 = TRUE\nx4 = \"Choć mieli do pokonania\"\n\n#używając funkcji paste, as.character, as.intiger połącz obiekty w jedno zdanie dodając własny tekst\n\n#wektory i listy\n\nwektor1 = c(1,2,3,4,5,10,50,80,1000)\n\nprint(sum(wektor1))\nprint(mean(wektor1))\nprint(median(wektor1))\n\nhist(wektor1)\n\n#operacja matematyczna na całym wektorze\nwektor2 = log1p(wektor1)\n\n#standaryzacja zmiennych z użyciem funkcji scale\nwektor3 = 1:100\nwektor4 = 101:200\n\nlength(wektor3) == length(wektor4)\n\nwektor3 == wektor4\n\nwektor3z = scale(wektor3)\nwektor4z = scale(wektor4)\n\n#sprawdźmy czy wektory są identyczne za pomocą różnicy zbiorów\n\nlength(setdiff(wektor3z,wektor4z)) == 0\n\n#sekwencje i powtórzenia\n\nwektor5 = seq(from = -10, to=100, by=0.3)\n\nwektor6 = rep(wektor5, times=10)\n\nwektor6_unq = sort(unique(wektor6))\n\nlength(setdiff(wektor5, wektor6_unq)) == 0 \n\n#obsługa braków danych\n\nwektor7 = c(4:10, NA, NaN)\n\nprint(mean(wektor7))\n\nprint(mean(wektor7, na.rm = T))\nprint(sum(wektor7, na.rm = T))\n\n#zastępowanie braków danych\n\nwektor8 = rep(c(1:1000, NA, NaN), 1000)\n\nis.na(wektor8[999:1020])\n\n#sprawdźmy ile mamy braków danych\ntable(is.na(wektor8))\n\n#zastąpmy je średnią\n\nwektor8[is.na(wektor8)] = mean(wektor8, na.rm = T)\n\ntable(is.na(wektor8))\n\n#usunięcie obiektu (bezpowrotne!!!)\n\nrm(wektor8)\n\n#jeszcze trochę operacji na wektorach\n\nwektor9 = 1:10\nwektor9[1:5]\nwektor9[c(1,5,9)]\nwektor9[10:1]\nwektor9[seq(from=5,to=9, by=2)]\n\nprint(wektor9 + wektor9)\nprint(wektor9 * wektor9)\n\n#nadpisanie fragmentu wektora\nwektor10 = 1:100\nwektor10[51:100] = rep(c(1,16),times=25)\n\n\n#lista\nlista1 = list(x=\"10\",y=10,a=TRUE,b= 1:100)\nprint(lista1)\nprint(lista1$x)\nprint(lista1$b)\n\n\n#macierze i tabele danych \n\nmacierz1 = matrix(1:1000, nrow=100, ncol=10)\nView(macierz1)\n\n#wyświetlimy pierwszy wiersz\nmacierz1[1,]\n\n#wiersze 1,10,21\n\nmacierz1[c(1,10,21),]\n\n#zastąpimy 10 kolumnę logarytmem z jej wartości\n\nmacierz1[,10] = log1p(macierz1[,10])\n\nView(macierz1)\n\n#znormalizujmy pierwsze 9 kolumn :) - skorzystajmy z funkcji apply (nieprawdopodobnie przydatna)\n\nmacierz1_norm = apply(X = macierz1[,1:9], MARGIN = 2, FUN=scale)\n\n#ale brakuje nam 10 kolumny z poprzedniej - uzupełnijmy to\n\nmacierz1_norm_10c = cbind(macierz1_norm, macierz1[,10])\n\nstr(macierz1_norm_10c)\nsummary(macierz1_norm_10c)\n\n\n\n######pętle FOR i WHILE\n\nsekwencja1 = seq(0,1,0.1)\n\ndane = sample(sekwencja1,size=100000, replace=T)\n\nmacierz2 = matrix(dane, nrow=100, ncol=1000)\n\nprint(str(macierz2))\n\n#zastosowanie funkcji do wszystkich kolumn macierzy z pętlą FOR\n\n\nmacierz2[1:10,1:10]\n\nfor (i in 1:ncol(macierz2)){\n\nmacierz2[,i]= scale(log1p(macierz2[,i]))\n  \n}\n\nmacierz2[1:10,1:10]\n\n#to samo z pętlą WHILE - trwa dopóki jakiś warunek jest prawdziwy, uwaga na INFINITE LOOP!\n\n#resetujemy macierz\nmacierz2 = matrix(dane, nrow=100, ncol=1000)\nmacierz2[1:10,1:10]\n\n\ni=1\n\nwhile (i<=ncol(macierz2)){\nmacierz2[,i]= scale(log1p(macierz2[,i]))\n#bardzo ważny element pętli WHILE poniżej\ni=i+1\n}\nmacierz2[1:10,1:10]\n\n\n#resetujemy macierz\nmacierz2 = matrix(dane, nrow=100, ncol=1000)\nmacierz2[1:10,1:10]\n\n\n# z wykorzystaniem if i break statement\ni=1\n\nwhile (1==1){\n  macierz2[,i]= scale(log1p(macierz2[,i]))\n  #bardzo ważny element pętli WHILE poniżej\n  i=i+1\n  #dodajemy break\n  if (i>ncol(macierz2)) {break}\n  }\nmacierz2[1:10,1:10]\n\n\n\n\n\n\n",
    "created" : 1483709203870.000,
    "dirty" : false,
    "encoding" : "WINDOWS-1252",
    "folds" : "",
    "hash" : "2748501129",
    "id" : "8377F09C",
    "lastKnownWriteTime" : 1483800755,
    "last_content_update" : 1483800755417,
    "path" : "C:/Users/msedek/Desktop/SWPS_Intro_To_R/Basic_R/basic_code.R",
    "project_path" : "basic_code.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}